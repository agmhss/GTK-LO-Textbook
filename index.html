<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Learning Outcomes ↔ Textbook Lesson Matcher</title>
  
  <!-- Reliable PDF.js version that exposes pdfjsLib globally -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
  
  <!-- Tesseract.js v5 -->
  <script src="https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js"></script>

  <style>
    * { box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      margin: 0; padding: 16px; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%);
    }
    .wrap {
      max-width: 900px; margin: 0 auto; background: #fff; border-radius: 16px;
      padding: 16px; box-shadow: 0 12px 30px rgba(0,0,0,.15);
    }
    h1 { text-align:center; margin-top: 4px; font-size: 1.4rem; }
    .block { border:1px dashed #ccd; border-radius:12px; padding:12px; margin-top:12px; }
    label { font-weight:600; font-size:.9rem; }
    input, select {
      width:100%; padding:8px 10px; margin-top:6px;
      border-radius:10px; border:1px solid #ccd; font-size:.9rem;
    }
    .row{display:flex;gap:8px;margin-top:8px;flex-wrap:wrap;}
    .row input{flex:1;min-width:90px;}
    button{
      width:100%; margin-top:10px; padding:10px 14px; border-radius:12px;
      border:none; font-weight:600; font-size:.95rem; color:#fff;
      background:linear-gradient(45deg,#667eea,#764ba2); cursor: pointer;
    }
    button:disabled{ background: #ccc !important; cursor: not-allowed; opacity: 0.7; }
    .btn-group { display: flex; gap: 10px; margin-top: 12px; }
    .download-btn { background: #10b981; flex: 1; }
    .copy-btn { background: #3b82f6; flex: 1; }
    .status{margin-top:8px;padding:8px;border-radius:8px;font-size:.85rem;}
    .ok{background:#e6ffed;color:#03543f;border:1px solid #a7f3d0;}
    .err{background:#fde8e8;color:#9b1c1c;border:1px solid #fecaca;}
    .lib-status { font-size: 0.75rem; text-align: center; margin-bottom: 10px; padding: 5px; border-radius: 5px; }
    #output{margin-top:16px;}
    .card{ background:linear-gradient(135deg,#f093fb 0%,#f5576c 100%); color:#fff;padding:12px;border-radius:12px;margin-bottom:10px; }
    .match{background:#fff;color:#123;padding:10px;border-radius:10px;margin-top:8px;}
    .spinner { display: inline-block; width: 12px; height: 12px; border: 2px solid rgba(255,255,255,.3); border-radius: 50%; border-top-color: #fff; animation: spin 1s infinite; margin-right: 8px; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
<div class="wrap">
  <h1>Learning Outcomes ↔ Textbook Lesson Matcher</h1>
  
  <div id="libIndicator" class="lib-status" style="background: #fffbeb; color: #d97706;">
    ⌛ Initializing PDF.js & Tesseract.js...
  </div>

  <div class="block">
    <label>Groq API key</label>
    <input type="password" id="apiKey" placeholder="gsk_xxxx" />
  </div>

  <div class="block">
    <label>Learning outcomes PDF (list of outcomes)</label>
    <input type="file" id="outPdf" accept="application/pdf" />
    <div class="row">
      <input type="number" id="outStart" placeholder="Start page (optional)" min="1" />
      <input type="number" id="outEnd" placeholder="End page (optional)" min="1" />
    </div>
    <button type="button" id="outBtn" disabled>Extract outcomes</button>
    <div id="outStatus"></div>
  </div>

  <div class="block">
    <label>Textbook PDF (full book or chapter)</label>
    <input type="file" id="tbPdf" accept="application/pdf" />
    <div class="row">
      <input type="number" id="tbStart" placeholder="Start page (optional)" min="1" />
      <input type="number" id="tbEnd" placeholder="End page (optional)" min="1" />
    </div>
    <button type="button" id="tbBtn" disabled>Extract textbook</button>
    <div id="tbStatus"></div>
  </div>

  <button id="analyzeBtn" type="button" disabled>Match Outcomes to Textbook Lessons</button>
  <div id="output"></div>
</div>

<script>
let outcomesText = "";
let textbookText = "";
let lastAnalysis = null;
let tesseractWorker = null;

async function initLibraries() {
  const indicator = document.getElementById('libIndicator');
  
  indicator.innerText = "⌛ Loading libraries...";

  // Poll until both libraries are loaded
  while (typeof pdfjsLib === 'undefined' || typeof Tesseract === 'undefined') {
    await new Promise(r => setTimeout(r, 200));
  }

  // Set matching PDF.js worker
  pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';

  // Create shared Tesseract worker
  indicator.innerText = "⌛ Initializing Tesseract worker...";
  tesseractWorker = await Tesseract.createWorker({
    logger: m => console.log('Tesseract progress:', m)
  });

  indicator.innerText = "✅ PDF.js & Tesseract.js Ready";
  indicator.style.background = "#ecfdf5";
  indicator.style.color = "#059669";

  document.getElementById('outBtn').disabled = false;
  document.getElementById('tbBtn').disabled = false;
}

window.addEventListener('load', initLibraries);

function setStatus(elId, msg, ok = true, loading = false) {
  const el = document.getElementById(elId);
  const spin = loading ? '<span class="spinner"></span>' : '';
  el.innerHTML = `<div class="status ${ok ? 'ok' : 'err'}">${spin}${msg}</div>`;
}

async function performOCROnPage(page) {
  if (!tesseractWorker) throw new Error("Tesseract worker not ready");

  const lang = document.getElementById("outputLang")?.value === "Tamil" ? "tam+eng" : "eng";
  await tesseractWorker.loadLanguage(lang);
  await tesseractWorker.initialize(lang);

  const viewport = page.getViewport({ scale: 2.0 });
  const canvas = document.createElement('canvas');
  canvas.height = viewport.height;
  canvas.width = viewport.width;
  const ctx = canvas.getContext('2d');

  await page.render({ canvasContext: ctx, viewport }).promise;

  const { data: { text } } = await tesseractWorker.recognize(canvas);
  return text.trim();
}

async function extractPdfText(file, startEl, endEl, statusId) {
  const data = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({ data }).promise;

  let from = 1;
  let to = pdf.numPages;
  if (startEl.value) from = Math.max(1, parseInt(startEl.value) || 1);
  if (endEl.value) to = Math.min(pdf.numPages, parseInt(endEl.value) || pdf.numPages);
  if (from > to) [from, to] = [to, from];

  let fullText = "";
  for (let i = from; i <= to; i++) {
    setStatus(statusId, `OCR page ${i}/${to}...`, true, true);
    const page = await pdf.getPage(i);
    const pageText = await performOCROnPage(page);
    fullText += `\n\n[Page ${i}]\n${pageText}`;
  }
  return fullText.trim();
}

async function extractOutcomes() {
  const file = document.getElementById("outPdf").files[0];
  if (!file) return setStatus("outStatus", "Select a PDF first", false);

  document.getElementById("outBtn").disabled = true;
  try {
    outcomesText = await extractPdfText(file, document.getElementById("outStart"), document.getElementById("outEnd"), "outStatus");
    setStatus("outStatus", `Extracted ${outcomesText.length.toLocaleString()} chars`, true);
    enableAnalyze();
  } catch (e) {
    setStatus("outStatus", "Error: " + e.message, false);
    console.error(e);
  } finally {
    document.getElementById("outBtn").disabled = false;
  }
}

async function extractTextbook() {
  const file = document.getElementById("tbPdf").files[0];
  if (!file) return setStatus("tbStatus", "Select a PDF first", false);

  document.getElementById("tbBtn").disabled = true;
  try {
    textbookText = await extractPdfText(file, document.getElementById("tbStart"), document.getElementById("tbEnd"), "tbStatus");
    setStatus("tbStatus", `Extracted ${textbookText.length.toLocaleString()} chars`, true);
    enableAnalyze();
  } catch (e) {
    setStatus("tbStatus", "Error: " + e.message, false);
    console.error(e);
  } finally {
    document.getElementById("tbBtn").disabled = false;
  }
}

function enableAnalyze() {
  const key = document.getElementById("apiKey").value.trim();
  document.getElementById("analyzeBtn").disabled = !(key && outcomesText && textbookText);
}

document.getElementById("apiKey").addEventListener("input", enableAnalyze);
document.getElementById("outBtn").addEventListener("click", extractOutcomes);
document.getElementById("tbBtn").addEventListener("click", extractTextbook);
document.getElementById("analyzeBtn").addEventListener("click", analyze);

async function analyze() {
  const key = document.getElementById("apiKey").value.trim();
  if (!key || !outcomesText || !textbookText) return;

  setStatus("output", "AI matching outcomes to textbook lessons...", true, true);
  document.getElementById("analyzeBtn").disabled = true;

  const outcomesSnippet = outcomesText.slice(0, 10000);
  const textbookSnippet = textbookText.slice(0, 20000);

  const prompt = `You are an expert educator. Extract the list of learning outcomes from the provided PDF text.
Then, go through the textbook content and find the specific lessons/chapters/sections that teach or cover each outcome.
Identify the page numbers and quote relevant parts.

Output ONLY valid JSON (no extra text):

{
  "outcomes": [
    {
      "outcome": "Full text of the learning outcome",
      "matchedLessons": [
        {
          "page": "Page number(s)",
          "section": "Section or lesson title (if detectable)",
          "quote": "Short relevant quote from textbook"
        },
        ...
      ]
    },
    ...
  ]
}

Learning Outcomes PDF text (may contain page markers):\n${outcomesSnippet}

Textbook PDF text (with page markers):\n${textbookSnippet}`;

  try {
    const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
      method: "POST",
      headers: {
        "Authorization": "Bearer " + key,
        "Content-Type": "application/json"
      },
      body: JSON.stringify({
        model: "llama-3.3-70b-versatile",
        messages: [{ role: "user", content: prompt }],
        response_format: { type: "json_object" },
        temperature: 0.5,
        max_tokens: 4096
      })
    });

    if (!res.ok) throw new Error((await res.json()).error?.message || "API error");

    const data = await res.json();
    lastAnalysis = JSON.parse(data.choices[0].message.content);
    renderResult(lastAnalysis);
  } catch (err) {
    setStatus("output", "Analysis failed: " + err.message, false);
    console.error(err);
  } finally {
    document.getElementById("analyzeBtn").disabled = false;
  }
}

function renderResult(data) {
  let html = `<div class="card"><strong>Matched Learning Outcomes to Textbook Lessons</strong></div>`;

  if (data.outcomes && data.outcomes.length > 0) {
    data.outcomes.forEach((o, i) => {
      html += `<div class="match">
        <h4>${i + 1}. Outcome: ${o.outcome || "N/A"}</h4>`;
      if (o.matchedLessons && o.matchedLessons.length > 0) {
        html += `<ul>`;
        o.matchedLessons.forEach(m => {
          html += `<li><strong>Page ${m.page}</strong> - ${m.section || "Section"}: "${m.quote}"</li>`;
        });
        html += `</ul>`;
      } else {
        html += `<p>No matching lesson found.</p>`;
      }
      html += `</div>`;
    });
  } else {
    html += `<div class="match">No outcomes detected.</div>`;
  }

  html += `<div class="btn-group">
    <button class="download-btn" onclick="downloadResult()">Download JSON</button>
    <button class="copy-btn" onclick="copyResult()">Copy JSON</button>
  </div>`;

  document.getElementById("output").innerHTML = html;
}

function downloadResult() {
  if (!lastAnalysis) return;
  const blob = new Blob([JSON.stringify(lastAnalysis, null, 2)], { type: 'application/json' });
  const a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'outcomes-matches.json';
  a.click();
}

async function copyResult() {
  if (!lastAnalysis) return;
  await navigator.clipboard.writeText(JSON.stringify(lastAnalysis, null, 2));
  alert("JSON copied to clipboard!");
}

window.addEventListener('unload', async () => {
  if (tesseractWorker) await tesseractWorker.terminate();
});
</script>
</body>
  </html>
